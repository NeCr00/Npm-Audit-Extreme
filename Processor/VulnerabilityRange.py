import re
from Processor.AdvisoriesVulnVersions import AdvisoriesVulnVersions


class VulnerabilityRange:

    # check if the version is vulnerable in ranges with format 1.x.0 or 1.1.x
    @staticmethod
    def is_version_inside_wildcard(version_wildcard, version_str):
        # Split the version_wildcard and version_str by '.' to get their parts
        version_wildcard_parts = re.split(r'\.', version_wildcard)
        version_str_parts = re.split(r'\.', version_str)

        # If the number of parts in version_wildcard and version_str don't match, return False
        if len(version_wildcard_parts) != len(version_str_parts):
            return False

        # Iterate through the parts of version_wildcard and version_str
        for i, wildcard_part in enumerate(version_wildcard_parts):
            # If the part in version_wildcard is 'x' or 'X', skip the comparison and move to the next part
            if wildcard_part == 'x' or wildcard_part == 'X':
                continue
            # If the parts don't match and the wildcard part isn't 'x' or 'X', return False
            elif wildcard_part != version_str_parts[i]:
                return False

        # If all parts match or are skipped (i.e., 'x' or 'X'), return True
        return True

    # Function to remove alpha, beta, and rc version identifiers from a version string
    @staticmethod
    def clean_version(version):
        if 'x' not in version and not 'X' in version:
            version = re.sub(r'(-?[a-zA-Z]+[^ ]*)', '', version)
        return version

    # Function to convert a version string into a tuple of integers
    @staticmethod
    def version_to_tuple(version):
        if not version:
            return (0, 0, 0)
        version_numbers = version.split(".")[:3]
        return tuple(map(int, version_numbers))

    # Function to check if a given version is vulnerable given a vulnerable version range
    @staticmethod
    def is_vulnerable(version, vul_version, advisory_url=None):
        # Clean the input version and convert it to a tuple

        clean_version_number = VulnerabilityRange.version_to_tuple(
            VulnerabilityRange.clean_version(version))

        # Clean the vulnerable version range
        vul_version = VulnerabilityRange.clean_version(vul_version)

        # Split the vulnerable version range into individual ranges
        
        ranges = re.split(r'\s*\|\|\s*', vul_version)

        # Loop through each range and check if the version is within that range
        for range_version in ranges:

            #if version is empty, then it means that all the versions are vulnerable
            if range_version == '':
                return True
            
            if '-' in range_version:
                bounds = range_version.split('-')
                if len(bounds) == 2:

                    # Convert the lower and upper bounds to tuples and check if the version is within that range
                    lower = VulnerabilityRange.version_to_tuple(
                        bounds[0].replace(' ', ''))
                    upper = VulnerabilityRange.version_to_tuple(
                        bounds[1].replace(' ', ''))
                    if lower <= clean_version_number <= upper:
                        return True

            elif '=>' in range_version and '<=' in range_version:
                # Range specified with a greater-than and a less-than-or-equal-to symbol
                lower, upper = re.findall(r'\d+\.\d+\.\d+', range_version)
                lower = VulnerabilityRange.version_to_tuple(
                    lower.strip('><= '))
                upper = VulnerabilityRange.version_to_tuple(
                    upper.strip('><= '))
                if lower <= clean_version_number <= upper:
                    return True

            elif '>=' in range_version and '<' in range_version:
                # Range specified with a greater-than-or-equal-to and a less-than symbol
                lower, upper = re.findall(r'\d+\.\d+\.\d+', range_version)
                lower = VulnerabilityRange.version_to_tuple(
                    lower.strip('><= '))
                upper = VulnerabilityRange.version_to_tuple(
                    upper.strip('><= '))
                if lower <= clean_version_number < upper:
                    return True

            elif '>' in range_version and '<=' in range_version:
                # Range specified with a greater-than and a less-than-or-equal-to symbol
                lower, upper = re.findall(r'\d+\.\d+\.\d+', range_version)
                lower = VulnerabilityRange.version_to_tuple(
                    lower.strip('><= '))
                upper = VulnerabilityRange.version_to_tuple(
                    upper.strip('><= '))
                if lower < clean_version_number <= upper:
                    return True

            elif '<=' in range_version:
                # Range specified with a less-than-or-equal-to symbol
                upper = VulnerabilityRange.version_to_tuple(
                    range_version.strip('><= '))
                if clean_version_number <= upper:
                    return True

            elif '<' in range_version:
                # Range specified with a less-than symbol
                upper = VulnerabilityRange.version_to_tuple(
                    range_version.strip('><= '))
                if clean_version_number < upper:
                    return True

            elif '>=' in range_version:
                # Range specified with a greater-than-or-equal-to symbol
                lower = VulnerabilityRange.version_to_tuple(
                    range_version.strip('><= '))
                if clean_version_number >= lower:
                    return True

            elif '>' in range_version:
                # Range specified with a greater-than symbol
                lower = VulnerabilityRange.version_to_tuple(
                    range_version.strip('><= '))
                if clean_version_number > lower:
                    return True

            elif 'x' in range_version or 'X' in range_version:
                version = VulnerabilityRange.clean_version(version)
                return VulnerabilityRange.is_version_inside_wildcard(range_version, version)

            elif '*' in range_version:
                return True

            elif VulnerabilityRange.version_to_tuple(range_version) == clean_version_number:
                return True

            '''
            elif '*' in range_version:
                # Check if the specific version is vulnerable using the advisory of the vulnerable package
                if not advisory_url:
                    return True
                affected_versions = AdvisoriesVulnVersions.get_advisories_html_affected_versions(
                    advisory_url)
                for affected_version in affected_versions:
                    if '*' in affected_version or VulnerabilityRange.is_vulnerable(version, affected_version, advisory_url):
                        return True
            '''

        # Version is not vulnerable
        return False
